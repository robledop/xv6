#include "types.h"
#include "defs.h"
#include "mmu.h"
#include "proc.h"
#include "x86.h"
#include "traps.h"
#include "spinlock.h"

/** @brief Interrupt descriptor table shared by all CPUs. */
struct gate_desc idt[256];
/** @brief Trap handler entry points generated by vectors.S. */
extern uint vectors[]; // in vectors.S: array of 256 entry pointers
/** @brief Spinlock protecting ticks. */
struct spinlock tickslock;
/** @brief Global tick counter incremented by the timer interrupt. */
uint ticks;

char* exception_messages[] = {
    "Division By Zero",
    "Debug",
    "Non Maskable Interrupt",
    "Breakpoint",
    "Into Detected Overflow",
    "Out of Bounds",
    "Invalid Opcode",
    "No Coprocessor",
    "Double Fault",
    "Coprocessor Segment Overrun",
    "Bad TSS",
    "Segment Not Present",
    "Stack Fault",
    "General Protection Fault",
    "Page Fault",
    "Unknown Interrupt",
    "x87 FPU Floating-Point Error",
    "Alignment Check",
    "Machine Check",
    "SIMD Floating-Point Exception",
    "Virtualization Exception",
    "Control Protection Exception",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Reserved",
    "Security Exception",
    "Reserved"
};

static INTERRUPT_CALLBACK_FUNCTION interrupt_callbacks[TOTAL_INTERRUPTS];

void idt_register_interrupt_callback(int interrupt, INTERRUPT_CALLBACK_FUNCTION interrupt_callback)
{
    if (interrupt < 0 || interrupt >= TOTAL_INTERRUPTS)
    {
        panic("idt_register_interrupt_callback: interrupt out of bounds");
    }
    interrupt_callbacks[interrupt] = interrupt_callback;
}


void syscall_handler(struct trapframe* tf)
{
    if (myproc()->killed)
    {
        exit();
    }
    myproc()->trap_frame = tf;
    syscall();
    if (myproc()->killed)
    {
        exit();
    }
}

void exception_handler(struct trapframe* tf)
{
    // Handle page fault separately to get the faulting address from CR2.
    if (tf->trapno == T_PGFLT)
    {
        uint faulting_address = rcr2();
        // Handle page fault (for example, by terminating the process).
        cprintf("Page fault at address 0x%x, eip 0x%x\n", faulting_address, tf->eip);
        myproc()->killed = 1;
        return;
    }

    if ((tf->cs & DPL_USER) == DPL_USER)
    {
        cprintf("Process %d USER MODE EXCEPTION: %s\n", myproc()->pid, exception_messages[tf->trapno]);
        cprintf("EIP: 0x%x\n", tf->eip);
        cprintf("CS: 0x%x\n", tf->cs);
        cprintf("EFLAGS: 0x%x\n", tf->eflags);
        myproc()->killed = 1;
        return;
    }

    cprintf("CPU %d KERNEL MODE EXCEPTION: %s\n", cpuid(), exception_messages[tf->trapno]);
    cprintf("EIP: 0x%x\n", tf->eip);
    cprintf("CS: 0x%x\n", tf->cs);
    cprintf("EFLAGS: 0x%x\n", tf->eflags);
    if ((tf->cs == (SEG_UCODE << 3)) | DPL_USER)
    {
        cprintf("ESP: 0x%x\n", tf->esp);
        cprintf("SS: 0x%x\n", tf->ss);
    }
    panic("exception_handler");
}


void timer_handler([[maybe_unused]] struct trapframe* tf)
{
    if (cpuid() == 0)
    {
        acquire(&tickslock);
        ticks++;
        wakeup(&ticks);
        release(&tickslock);
    }
    lapiceoi(); // Acknowledge the interrupt
}

void ide_handler([[maybe_unused]] struct trapframe* tf)
{
    ideintr();
    lapiceoi(); // Acknowledge the interrupt
}

void keyboard_handler([[maybe_unused]] struct trapframe* tf)
{
    kbdintr();
    lapiceoi(); // Acknowledge the interrupt
}

void uart_handler([[maybe_unused]] struct trapframe* tf)
{
    uartintr();
    lapiceoi(); // Acknowledge the interrupt
}

void spurious_handler(struct trapframe* tf)
{
    cprintf("cpu%d: spurious interrupt at %x:%x\n",
            cpuid(), tf->cs, tf->eip);
    lapiceoi();
}

/**
 * @brief Initialize the IDT entries for traps and interrupts.
 */
void tvinit(void)
{
    for (int i = 0; i < 256; i++)
    {
        SETGATE(idt[i], 0, SEG_KCODE << 3, vectors[i], 0);
    }
    SETGATE(idt[T_SYSCALL], 1, SEG_KCODE << 3, vectors[T_SYSCALL], DPL_USER);


    for (int i = 0; i < 0x20; i++)
    {
        idt_register_interrupt_callback(i, exception_handler);
    }

    idt_register_interrupt_callback(T_SYSCALL, syscall_handler);
    idt_register_interrupt_callback(T_IRQ0 + IRQ_TIMER, timer_handler);
    idt_register_interrupt_callback(T_IRQ0 + IRQ_IDE, ide_handler);
    idt_register_interrupt_callback(T_IRQ0 + IRQ_KBD, keyboard_handler);
    idt_register_interrupt_callback(T_IRQ0 + IRQ_COM1, uart_handler);
    idt_register_interrupt_callback(T_IRQ0 + IRQ_SPURIOUS, spurious_handler);
    idt_register_interrupt_callback(T_IRQ0 + 7, spurious_handler);

    initlock(&tickslock, "time");
}

/** @brief Load the IDT register with the kernel's descriptor table. */
void idtinit(void)
{
    lidt(idt, sizeof(idt));
}


/**
 * @brief Central trap and interrupt dispatcher.
 *
 * @param tf Trap frame captured at the time of the trap/interrupt.
 */
void trap(struct trapframe* tf)
{
    if (interrupt_callbacks[tf->trapno])
    {
        interrupt_callbacks[tf->trapno](tf);
    }
    else
    {
        if (myproc() == 0 || (tf->cs & 3) == 0)
        {
            // In kernel, it must be our mistake.
            cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
                    tf->trapno, cpuid(), tf->eip, rcr2());
            panic("trap");
        }
        // In user space, assume process misbehaved.
        cprintf("pid %d %s: trap %d err %d on cpu %d "
                "eip 0x%x addr 0x%x--kill proc\n",
                myproc()->pid, myproc()->name, tf->trapno,
                tf->err, cpuid(), tf->eip, rcr2());
        myproc()->killed = 1;
    }

    // Force process exit if it has been killed and is in user space.
    // (If it is still executing in the kernel, let it keep running
    // until it gets to the regular system call return.)
    if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
        exit();

    // Force the process to give up CPU on clock tick.
    // If interrupts were on while locks held, would need to check nlock.
    if (myproc() && myproc()->state == RUNNING &&
        tf->trapno == T_IRQ0 + IRQ_TIMER)
        yield();

    // Check if the process has been killed since we yielded
    if (myproc() && myproc()->killed && (tf->cs & 3) == DPL_USER)
        exit();
}
